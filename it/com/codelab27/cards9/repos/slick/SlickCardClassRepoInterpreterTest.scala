package com.codelab27.cards9.repos.slick

import java.net.URL

import com.codelab27.cards9.models.cards.CardClass
import org.scalatest.concurrent.ScalaFutures._
import org.scalatest.{BeforeAndAfterAll, Matchers, WordSpec}

import scala.concurrent.Await
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._

class SlickCardClassRepoInterpreterTest extends WordSpec with Matchers with BeforeAndAfterAll {

  private implicit val patienceConfig = PatienceConfig(10.seconds, 50.millis)

  private val interpreter = H2CardClassRepoInterpreter
  private val db = interpreter.db

  override def beforeAll(): Unit = {
    Await.result(db.run(interpreter.createTable), 1.second)
  }

  override def afterAll(): Unit = {
    Await.result(db.shutdown, 1.second)
  }

  "A card class" when {

    "stored" should {

      val exampleCardClass = CardClass(
        CardClass.Name("chocobo"),
        new URL("http://vignette1.wikia.nocookie.net/finalfantasy/images/f/fc/CT_Chocobo.png/revision/latest?cb=20151127205658"),
        None)

      "be retrieved with an autogenerated id" in {

        val attemptStore = for {
          cardClassId <- interpreter.storeCardClass(exampleCardClass)
        } yield {
          cardClassId
        }

        whenReady(db.run(attemptStore)) {
          case Some(id) => id.value.isValidInt
          case None     => fail("Not stored card class")
        }
      }

      "replace the previous card class" in {

        val chocoName = CardClass.Name("choco")

        val attemptReplace = for {
          cardClassId     <- interpreter.storeCardClass(exampleCardClass)
          _               <- interpreter.storeCardClass(exampleCardClass.copy(id = cardClassId, name = chocoName))
          maybeReplacedCC <- interpreter.findCardClass(cardClassId)
        } yield {
          maybeReplacedCC
        }

        whenReady(db.run(attemptReplace)) {
          case Some(CardClass(name, _, _))  => name.value shouldBe "choco"
          case None                         => fail("Not found card class")
        }

      }

      "be available to delete it" in {

        val attemptDelete = for {
          cardClassId <- interpreter.storeCardClass(exampleCardClass)
          _           <- interpreter.deleteCardClass(cardClassId)
        } yield {
          true
        }

        whenReady(db.run(attemptDelete)) { result => result shouldBe true }

      }

    }

  }

}
